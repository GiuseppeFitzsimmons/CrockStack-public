const AWS = require('real-aws-sdk');
/*
crock-aws-sdk overrides certain classes and functions of the real AWS SDK.
There are some functions provided by the AWS SDK which won't work without an AWS
context but can be mapped to CrockStack functionality, such as inoking another lambda.

For refereence, when required to return a Request object, this is what it should look like.
https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Request.html#promise-property
*/

const bastardised = AWS
bastardised.isBroughtToYouBy = "CrockStack";
bastardised.superLambda = bastardised.Lambda;
class UnderLambda {
    /*
    https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Lambda.html
    */
    constructor(params) {
        //super(params);
        var aLambda = new bastardised.superLambda(params);
        Object.assign(this, aLambda);
    }
    invoke(params) {
        let lambdaToInvoke = stack.Resources[params.FunctionName];
        console.log("Not yet implemented. This is where we'll call up to the stack to execute another lambda", lambdaToInvoke);
    }
}
bastardised.superApiGatewayManagementApi = bastardised.ApiGatewayManagementApi;

class UnderApiGatewayManagementApi {
    /*
    https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/ApiGatewayManagementApi.html
    The real ApiGatewayManagementApi is quite simple - it exposes three functions for managing
    websocket connections. Ours do the same thing. There's a dictionary of connections in
    a global object called stack (there's really no avoiding a global for this). The dictionary
    is called webSocketConnections, and it looks like this
    {
        ad2x-4Dde-De09-cIx1: connection,
        8DvV-6n83-txX5-elL8: connection
    }
    The connection is a websocket implementation capable of sending and receiving messages
    */
    constructor(params) {
        var aApiGatewayManagementApi = new bastardised.superApiGatewayManagementApi(params);
        Object.assign(this, aApiGatewayManagementApi);
    }
    postToConnection(params, callback) {
        const sendMessage=function(connectionId, data, callback) {
            let connection=stack.connections[connectionId];
            if (!connection) {
                callback({statusCode: 410})
            } else {
                connection.sendMessage(data, function(error, data) {
                    callback(error, data);
                })
            }
        }
        //Params will look like this { ConnectionId: connectionId, Data: postData }
        //We want to find the connection corresponding to the ID, and send it the data
        //We need to return a promise capable of rejecting with an error which has a statusCode
        if (callback) {
            sendMessage(params.ConnectionId, params.Data, callback);
        } else {
            let request={};
            request.send=function(sendCallBack) {
                if (!sendCallBack) {
                    sendCallBack=function(error, data) {
                        console.log(error, data);
                    }
                }
                sendMessage(params.ConnectionId, params.Data, sendCallBack);
            }
            request.promise=function() {
                return new Promise( ( resolve, reject ) => {
                    sendMessage(params.ConnectionId, params.Data, (error, data)=>{
                        if (error) {
                            console.log("Error trying to send a message - we'll assume that this is a stale connection", error);
                            delete stack.connections[params.ConnectionId];
                            reject({statusCode: 410});
                        } else {
                            resolve(data);
                        }
                    });
                })
            }
            return request;
        }
    }
    getConnection(params, callback) {
        //Do we need to implement this?
        //{ ConnectionId: connectionId }
        //It's probably easily done - we just need to get the connection from the dictionary of connections
        //and return an object that looks like this
        //{ConnectedAt: '2020-07-16T19:20:30.45+01:00',
        //  Identity: {
        //      SourceIp: '192.169.0.50',
        //      UserAgent: 'Mozilla v12.0'
        //  }
        //  LastActiveAt: '2020-07-16T19:20:30.45+01:00'
        //}
        let connection=stack.connections[params.ConnectionId];
        let detail, error;
        if (connection) {
            try {
                detail=connection.getConnectionDetail();
            } catch (e) {
                error={statusCode:410}
            }
        } else {
            error={statusCode:410}
        }
        if (callback) {
            callback(error, detail);
        } else {
            let request={};
            request.send=function(callback) {
                if (callback) {
                    callback(error, detail);
                }
            }
            request.promise=function() {
                return new Promise( ( resolve, reject ) => {
                    if (error) {
                        reject(error);
                    } else {
                        resolve(detail);
                    }
                })
            }
            return request;
        }
    }
    deleteConnection(params) {
        //{ ConnectionId: connectionId }
        //Call close on the connection and remove it from the dictionary of connections
        let connection=stack.connections[params.ConnectionId];
        let detail, error;
        if (connection) {
            try {
                detail=connection.disconnect();
                delete stack.connections[params.ConnectionId];
            } catch (e) {
                error={statusCode:410}
            }
        } else {
            error={statusCode:410}
        }
        if (callback) {
            callback(error, detail);
        } else {
            let request={};
            request.send=function(callback) {
                if (callback) {
                    callback(error, detail);
                }
            }
            request.promise=function() {
                return new Promise( ( resolve, reject ) => {
                    if (error) {
                        reject(error);
                    } else {
                        resolve(detail);
                    }
                })
            }
            return request;
        }
    }
}

bastardised.ApiGatewayManagementApi = UnderApiGatewayManagementApi
bastardised.Lambda = UnderLambda

module.exports = bastardised;

